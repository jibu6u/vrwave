<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VR Wave Mixer — Seed Input Safe Mode (Oculus/WebXR)</title>
<style>
  :root { color-scheme: dark; }
  html, body { height:100%; }
  body { margin:0; background:#0b0b0d; color:#e5e7eb; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

  .ui {
    position: fixed; left: 0; top: 0; z-index: 10;
    width: min(580px, 96vw);
    padding: 12px;
    display: flex; flex-direction: column; gap: 10px;
    background: linear-gradient(180deg, #0b0b0deb, #0b0b0db3 40%, transparent);
  }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  button { padding:8px 12px; border-radius:10px; border:1px solid #3a3a3a; background:#141416; color:#fff; cursor:pointer; }
  button[disabled] { opacity:.5; cursor:not-allowed; }
  button:hover:not([disabled]) { background:#1b1d20; }

  #seedWrap { position:relative; display:inline-block; }
  #seedCanvas {
    display:block; width:420px; height:220px;
    background:#000; border:1px dashed #666; border-radius:10px;
    cursor: crosshair; touch-action:none; pointer-events:auto;
  }
  #seedDbg, #eventDbg { font:12px/1.35 monospace; color:#cbd5e1; white-space:pre; }
  .hint { color:#9ca3af; font-size:12px; }

  canvas.webgl {
    position: fixed; inset: 0; z-index: 0; display:block;
    width:100vw !important; height:100vh !important;
  }
</style>
</head>
<body>

<div class="ui">
  <div class="row">
    <button id="btnStart" disabled>Start</button>
    <button id="btnReset">Reset</button>
    <button id="btnInputFix">🛠️ 입력 안됨 해결: OFF</button>
    <button id="btnAuto7">🎲 7점 자동생성</button>
    <div style="flex:1 1 auto;"></div>
    <div>
      <div id="seedDbg">7개의 점을 찍어 시드를 만드세요.</div>
      <div id="eventDbg">event: - / x:- y:- / rect: -</div>
    </div>
  </div>

  <div class="row">
    <div id="seedWrap">
      <canvas id="seedCanvas" title="여기에 7번 클릭/탭"></canvas>
    </div>
    <div>Clicks: <b id="clickCount">0</b>/7</div>
    <button id="btnClearPts">Clear</button>
  </div>

  <div class="hint">
    7점이 찍히면 폐곡선을 보여주고 Start가 활성화됩니다. <b>안 찍히면</b> 먼저
    <b>‘입력 안됨 해결’</b>을 켠 뒤 다시 시도하세요. 그래도 안 되면 <b>‘7점 자동생성’</b>으로 진행 가능합니다.
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";
import { VRButton } from "https://unpkg.com/three@0.160.1/examples/jsm/webxr/VRButton.js";
import { Line2 } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/Line2.js";
import { LineMaterial } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/LineMaterial.js";
import { LineGeometry } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/LineGeometry.js";

/* ========== Seed 캔버스 (안전 입력) ========== */
const seedWrap = document.getElementById('seedWrap');
const seedCanvas = document.getElementById('seedCanvas');
const sctx = seedCanvas.getContext('2d', { alpha:false });
const seedDbg = document.getElementById('seedDbg');
const eventDbg = document.getElementById('eventDbg');
const TX_CNT = document.getElementById('clickCount');

const BTN_START = document.getElementById('btnStart');
const BTN_RST   = document.getElementById('btnReset');
const BTN_CLR   = document.getElementById('btnClearPts');
const BTN_FIX   = document.getElementById('btnInputFix');
const BTN_AUTO7 = document.getElementById('btnAuto7');

let points = [], seedReady = false;
let flashAt = null, lastAddTs = 0;
let inputFixOn = false;

function updateEventDbg(type, x, y, rect) {
  const rtxt = rect ? `${Math.round(rect.left)},${Math.round(rect.top)}  ${Math.round(rect.width)}×${Math.round(rect.height)}` : '-';
  eventDbg.textContent = `event: ${type} / x:${x} y:${y} / rect: ${rtxt}`;
}

function syncCanvasSize() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = seedCanvas.getBoundingClientRect();
  const w = Math.max(2, Math.round(rect.width  * dpr));
  const h = Math.max(2, Math.round(rect.height * dpr));
  if (seedCanvas.width !== w || seedCanvas.height !== h) {
    seedCanvas.width  = w;
    seedCanvas.height = h;
  }
  sctx.setTransform(dpr,0,0,dpr,0,0); // CSS 좌표계=그리기 좌표계
  drawSeedBoard();
  updateEventDbg('-', '-', '-', rect);
}
const ro = new ResizeObserver(syncCanvasSize);
ro.observe(seedCanvas);
window.addEventListener('resize', syncCanvasSize);
syncCanvasSize();

function drawSeedBoard() {
  const rect = seedCanvas.getBoundingClientRect();
  sctx.fillStyle = '#000'; sctx.fillRect(0,0,rect.width, rect.height);
  sctx.strokeStyle = '#666'; sctx.setLineDash([6,4]);
  sctx.strokeRect(1,1,rect.width-2, rect.height-2);
  sctx.setLineDash([]);

  for (const p of points) {
    sctx.fillStyle = '#ff4d6d';
    sctx.beginPath(); sctx.arc(p.x, p.y, 5, 0, Math.PI*2); sctx.fill();
  }

  if (flashAt && performance.now() < flashAt.until) {
    sctx.strokeStyle = '#ffd166'; sctx.lineWidth = 2;
    sctx.beginPath(); sctx.arc(flashAt.x, flashAt.y, 10, 0, Math.PI*2); sctx.stroke();
    requestAnimationFrame(drawSeedBoard);
  } else { flashAt = null; }

  if (points.length === 7) {
    sctx.strokeStyle = '#94a3b8'; sctx.lineWidth = 2; sctx.lineCap='round'; sctx.lineJoin='round';
    sctx.beginPath(); sctx.moveTo(points[0].x, points[0].y);
    for (let i=1;i<7;i++) sctx.lineTo(points[i].x, points[i].y);
    sctx.lineTo(points[0].x, points[0].y); sctx.stroke();
    seedDbg.textContent = "시드 준비 완료. Start를 누르고 VR로 보세요.";
  } else {
    seedDbg.textContent = "7개의 점을 찍어 시드를 만드세요.";
  }
}

function withinRect(x, y, rect) { return (x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom); }
function clientToCanvas(x, y, rect) { return { x: Math.max(0, Math.min(rect.width,  x-rect.left)), y: Math.max(0, Math.min(rect.height, y-rect.top)) }; }

function tryAddPointFromClient(clientX, clientY, typeLabel='-') {
  const now = performance.now();
  if (now - lastAddTs < 60) return; // 중복 방지
  const rect = seedCanvas.getBoundingClientRect();
  if (!withinRect(clientX, clientY, rect)) return;
  const { x, y } = clientToCanvas(clientX, clientY, rect);
  points.push({ x: Math.round(x), y: Math.round(y) });
  TX_CNT.textContent = String(points.length);
  flashAt = { x, y, until: now + 220 };
  updateEventDbg(typeLabel, Math.round(x), Math.round(y), rect);
  if (points.length === 7) { seedReady = true; BTN_START.disabled = false; }
  lastAddTs = now;
  drawSeedBoard();
}

/* 입력 리스너 (타겟 + 부모 + 전역) */
// 타겟: 캔버스 자체
seedCanvas.addEventListener('pointerdown', e=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'canvas:pointerdown'); }, {passive:false});
seedCanvas.addEventListener('mousedown',   e=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'canvas:mousedown');   }, {passive:false});
seedCanvas.addEventListener('click',       e=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'canvas:click');       }, {passive:false});
seedCanvas.addEventListener('touchstart',  e=>{ const t=e.changedTouches?.[0]; if(t){ tryAddPointFromClient(t.clientX, t.clientY, 'canvas:touchstart'); e.preventDefault(); }}, {passive:false});
seedCanvas.addEventListener('touchend',    e=>{ const t=e.changedTouches?.[0]; if(t){ tryAddPointFromClient(t.clientX, t.clientY, 'canvas:touchend');   e.preventDefault(); }}, {passive:false});

// 부모: seedWrap (타겟팅 실패 대비)
seedWrap.addEventListener('pointerdown', e=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'wrap:pointerdown'); }, {passive:false});
seedWrap.addEventListener('mousedown',   e=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'wrap:mousedown');   }, {passive:false});
seedWrap.addEventListener('click',       e=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'wrap:click');       }, {passive:false});
seedWrap.addEventListener('touchstart',  e=>{ const t=e.changedTouches?.[0]; if(t){ tryAddPointFromClient(t.clientX, t.clientY, 'wrap:touchstart'); e.preventDefault(); }}, {passive:false});
seedWrap.addEventListener('touchend',    e=>{ const t=e.changedTouches?.[0]; if(t){ tryAddPointFromClient(t.clientX, t.clientY, 'wrap:touchend');   e.preventDefault(); }}, {passive:false});

// 전역: 다른 요소가 덮어써도 rect 안이면 채택
document.addEventListener('pointerdown', e=>{ tryAddPointFromClient(e.clientX, e.clientY, 'doc:pointerdown'); }, {passive:true});
document.addEventListener('mousedown',   e=>{ tryAddPointFromClient(e.clientX, e.clientY, 'doc:mousedown');   }, {passive:true});
document.addEventListener('click',       e=>{ tryAddPointFromClient(e.clientX, e.clientY, 'doc:click');       }, {passive:true});
document.addEventListener('touchstart',  e=>{ const t=e.changedTouches?.[0]; if(t) tryAddPointFromClient(t.clientX, t.clientY, 'doc:touchstart'); }, {passive:true});
document.addEventListener('touchend',    e=>{ const t=e.changedTouches?.[0]; if(t) tryAddPointFromClient(t.clientX, t.clientY, 'doc:touchend');   }, {passive:true});

/* 비상 기능 */
BTN_FIX.addEventListener('click', ()=>{
  inputFixOn = !inputFixOn;
  // WebGL 캔버스가 입력을 가로채는 경우 차단
  const gl = document.querySelector('canvas.webgl');
  if (gl) gl.style.pointerEvents = inputFixOn ? 'none' : 'auto';
  BTN_FIX.textContent = `🛠️ 입력 안됨 해결: ${inputFixOn ? 'ON' : 'OFF'}`;
});
BTN_AUTO7.addEventListener('click', ()=>{
  const rect = seedCanvas.getBoundingClientRect();
  points = [];
  for (let i=0;i<7;i++){
    const x = Math.round((rect.width  * (0.08 + Math.random()*0.84)));
    const y = Math.round((rect.height * (0.12 + Math.random()*0.76)));
    points.push({x,y});
  }
  TX_CNT.textContent = '7'; seedReady = true; BTN_START.disabled = false;
  drawSeedBoard();
});
BTN_CLR.addEventListener('click', ()=>{
  points = []; TX_CNT.textContent = '0'; seedReady = false; BTN_START.disabled = true; drawSeedBoard();
});

/* ========== RNG & Wave & WebXR (이전과 동일 로직, 요약) ========== */
function fnv1a32_fromPoints(pts){ let h=0x811c9dc5>>>0; for(const p of pts){ const xi=p.x|0, yi=p.y|0;
  h^=(xi&0xff); h=Math.imul(h,0x01000193); h^=((xi>>>8)&0xff); h=Math.imul(h,0x01000193);
  h^=(yi&0xff); h=Math.imul(h,0x01000193); h^=((yi>>>8)&0xff); h=Math.imul(h,0x01000193);} return h>>>0; }
function mulberry32(seed){ let a=seed>>>0; return function(){ a=(a+0x6D2B79F5)>>>0;
  let t=Math.imul(a^(a>>>15),(a|1)); t^=t+Math.imul(t^(t>>>7),(t|61)); return ((t^(t>>>14))>>>0)/4294967296; }; }
function laneSeed(seed32,i){ let x=(seed32^(i*0x9E3779B9))>>>0; x^=x<<13; x^=x>>>17; x^=x<<5; return x>>>0; }

class Wave{
  constructor(idx, rng, inv=false){
    this.idx=idx; this.periodPx=380+rng()*280;
    this.a1=0.50+rng()*0.25;
    this.a2=(0.08+rng()*0.10)*(rng()<0.7?1:0.6);
    this.a3=(rng()<0.35)?(0.04+rng()*0.06):0;
    this.p1=rng()*Math.PI; this.p2=this.p1*0.5+rng()*0.6; this.p3=this.p1*0.33+rng()*0.6;
    this.bias=(rng()*0.06-0.03); this.troughBoost=1.3+rng()*0.9; this.hue=Math.floor(rng()*360);
    this.inv=inv;
  }
  base(t){ return this.a1*Math.sin(t+this.p1)+this.a2*Math.sin(2*t+this.p2)+this.a3*Math.sin(3*t+this.p3)+this.bias; }
  asym(v){ const a=0.22; const w=0.5*(1-Math.tanh(v/a)); let o=v*(1+(this.troughBoost-1)*w); if(this.inv) o=-o; return Math.tanh(o*0.9)*1.05; }
  sample(u){ return this.asym(this.base(u*2*Math.PI)); }
}

/* WebXR/Three */
let renderer, scene, camera, world;
const LINES=[]; const NUM_SAMPLES=1024; const WIDTH=4.2; const HEIGHT=1.6;
let materialResolution=new THREE.Vector2();

function setupThree(){
  renderer=new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
  renderer.xr.enabled=true;
  renderer.domElement.classList.add('webgl');
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0b0d);
  camera=new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 100); camera.position.set(0,1.6,0.5);
  scene.add(new THREE.HemisphereLight(0xffffff, 0x202025, 0.7));
  world=new THREE.Group(); world.position.set(0,1.6,-2.2); scene.add(world);

  const baseline=new THREE.Mesh(new THREE.PlaneGeometry(WIDTH,0.004), new THREE.MeshBasicMaterial({color:0x2b2b33}));
  world.add(baseline);

  function onResize(){
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
    materialResolution.set(innerWidth, innerHeight);
    for(const e of LINES) e.material.resolution.copy(materialResolution);
  }
  addEventListener('resize', onResize); onResize();
}

function makeLineMaterial(h, a=1.0){ const m=new LineMaterial({
  color:new THREE.Color(`hsl(${h},100%,60%)`).getHex(), linewidth:0.02, transparent:a<1, opacity:a, depthTest:true
}); m.resolution.copy(materialResolution); return m; }

function createWaveLine(w, a=1.0){ const g=new LineGeometry(); const arr=new Float32Array(NUM_SAMPLES*3);
  g.setPositions(arr); const mat=makeLineMaterial(w.hue, a); const line=new Line2(g,mat); line.computeLineDistances(); world.add(line);
  return {mesh:line, geometry:g, positions:arr, material:mat, wave:w}; }

function updateLinePositions(e, phase){ const {positions, geometry, wave}=e;
  for(let i=0;i<NUM_SAMPLES;i++){ const u=i/(NUM_SAMPLES-1); const x=-WIDTH/2+u*WIDTH; const y=wave.sample((u+phase)%1)* (HEIGHT*0.5);
    const j=i*3; positions[j]=x; positions[j+1]=y; positions[j+2]=0; } geometry.setPositions(positions); }

function clearWorld(){ for(const e of LINES){ world.remove(e.mesh); e.geometry.dispose(); e.material.dispose(); } LINES.length=0; }

class WaveFactory{
  constructor(sd){ this.sd=sd; this.norm=[]; this.inv=[];
    for(let i=0;i<10;i++){ this.norm.push(new Wave(i, mulberry32(laneSeed(sd,i)), false)); this.inv.push(new Wave(i, mulberry32(laneSeed(sd,i+97)), true)); }}
  pick(arr,r,n=5){ const idx=arr.map((_,i)=>i); for(let i=idx.length-1;i>0;i--){ const j=Math.floor(r()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; } return idx.slice(0,n).map(i=>arr[i]); }
  build(){ clearWorld(); const r1=mulberry32(this.sd^0xabc12345), r2=mulberry32(this.sd^0x13579bdf);
    const chosen=[...this.pick(this.norm,r1,5), ...this.pick(this.inv,r2,5)];
    chosen.forEach((w,k)=>{ const a=Math.max(0.6, 0.9-k*0.02); LINES.push(createWaveLine(w,a)); });
  }
}

let running=false, factory=null;
function startAnimation(){ if(running) return; running=true;
  renderer.setAnimationLoop(()=>{ const t=performance.now()*0.001; const phase=(t*0.075)%1.0; for(const e of LINES) updateLinePositions(e,phase); renderer.render(scene,camera); });
}
function stopAnimation(){ running=false; renderer.setAnimationLoop(null); }

/* UI 동작 */
BTN_START.addEventListener('click', ()=>{
  if (!seedReady || points.length!==7) { alert('먼저 7점을 찍어주세요.'); return; }
  const seed32 = fnv1a32_fromPoints(points);
  factory = new WaveFactory(seed32); factory.build(); startAnimation();
});
BTN_RST.addEventListener('click', ()=>{
  stopAnimation(); clearWorld(); points=[]; seedReady=false; TX_CNT.textContent='0'; BTN_START.disabled=true; drawSeedBoard();
});

/* 초기화 */
function init(){ drawSeedBoard(); setupThree(); }
init();
</script>
</body>
</html>
