<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VR Wave Mixer — 7-point Seed (Bulletproof Input) → Mix 10 (Oculus/WebXR)</title>
<style>
  :root { color-scheme: dark; }
  html, body { height:100%; }
  body { margin:0; background:#0b0b0d; color:#e5e7eb; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

  /* UI 패널 (항상 WebGL 위) */
  .ui {
    position: fixed; left: 0; top: 0; z-index: 10;
    width: min(560px, 96vw);
    padding: 12px;
    display: flex; flex-direction: column; gap: 10px;
    background: linear-gradient(180deg, #0b0b0deb, #0b0b0db3 40%, transparent);
    pointer-events: auto;
  }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  button {
    padding:8px 14px; border-radius:10px;
    border:1px solid #3a3a3a; background:#141416; color:#fff; cursor:pointer;
  }
  button[disabled] { opacity:.5; cursor:not-allowed; }
  button:hover:not([disabled]) { background:#1b1d20; }
  #seedWrap { position:relative; }
  #seedCanvas {
    display:block; width:420px; height:220px;  /* 초기 레이아웃만, 내부 픽셀은 동적으로 맞춤 */
    background:#000; border:1px dashed #666; border-radius:10px;
    cursor: crosshair; touch-action: none; pointer-events: auto;
  }
  #seedDbg, #eventDbg { font:12px/1.35 monospace; color:#cbd5e1; white-space:pre; }
  .hint { color:#9ca3af; font-size:12px; }

  /* WebGL 캔버스는 화면 전체 뒤쪽 */
  canvas.webgl {
    position: fixed; inset: 0; z-index: 0; display:block;
    width: 100vw !important; height: 100vh !important;
  }
</style>
</head>
<body>

<!-- UI -->
<div class="ui">
  <div class="row">
    <button id="btnStart" disabled>Start → Build & Animate</button>
    <button id="btnReset">Reset</button>
    <div style="flex:1 1 auto;"></div>
    <div>
      <div id="seedDbg">7개의 점을 찍어 시드를 만드세요.</div>
      <div id="eventDbg">event: - / x:- y:- / rect: -</div>
    </div>
  </div>
  <div class="row">
    <div id="seedWrap">
      <canvas id="seedCanvas" title="여기에 7번(정확히) 클릭/탭하여 시드 생성"></canvas>
    </div>
    <div>Clicks: <b id="clickCount">0</b>/7</div>
    <button id="btnClearPts">Clear Points</button>
  </div>
  <div class="hint">
    7점을 찍으면 선이 <b>폐곡선</b>으로 표시됩니다. Start를 누르면 같은 시드로 생성한
    <b>정상 10</b>과 <b>인버티드 10</b> 중 <b>각 5개</b>를 랜덤으로 뽑아 총 <b>10개</b>를
    한 화면에 겹쳐 흐르게 합니다. 상단의 “Enter VR” 버튼으로 Oculus에서 보세요.
  </div>
</div>

<!-- Three.js + WebXR + 굵은 라인(Line2) -->
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";
import { VRButton } from "https://unpkg.com/three@0.160.1/examples/jsm/webxr/VRButton.js";
import { Line2 } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/Line2.js";
import { LineMaterial } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/LineMaterial.js";
import { LineGeometry } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/LineGeometry.js";

/* ---------- Seed UI (입력 초탄착 보장) ---------- */
const seedCanvas = document.getElementById('seedCanvas');
const sctx = seedCanvas.getContext('2d');
const seedDbg = document.getElementById('seedDbg');
const eventDbg = document.getElementById('eventDbg');
const TX_CNT = document.getElementById('clickCount');
const BTN_START = document.getElementById('btnStart');
const BTN_RST = document.getElementById('btnReset');
const BTN_CLR = document.getElementById('btnClearPts');

let points = [], seedReady = false;
let flashAt = null; // 클릭 하이라이트
let lastAddTs = 0;

// ★ 캔버스 내부 픽셀 크기를 "보이는 크기 × DPR"에 항상 맞춤
const ro = new ResizeObserver(syncCanvasSize);
ro.observe(seedCanvas);
window.addEventListener('resize', syncCanvasSize);
syncCanvasSize();

function syncCanvasSize() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = seedCanvas.getBoundingClientRect();
  const w = Math.max(2, Math.round(rect.width  * dpr));
  const h = Math.max(2, Math.round(rect.height * dpr));
  if (seedCanvas.width !== w || seedCanvas.height !== h) {
    seedCanvas.width = w;
    seedCanvas.height = h;
    sctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 뷰 좌표계=CSS 좌표계
  }
  drawSeedBoard();
  updateEventDbg('-', '-', '-', rect);
}

function drawSeedBoard() {
  const rect = seedCanvas.getBoundingClientRect();
  sctx.fillStyle = '#000'; sctx.fillRect(0,0,rect.width, rect.height);
  sctx.strokeStyle = '#666'; sctx.setLineDash([6,4]);
  sctx.strokeRect(1,1,rect.width-2, rect.height-2);
  sctx.setLineDash([]);

  // 점들
  for (const p of points) {
    sctx.fillStyle = '#ff4d6d';
    sctx.beginPath(); sctx.arc(p.x, p.y, 5, 0, Math.PI*2); sctx.fill();
  }

  // 클릭 하이라이트(0.2초)
  if (flashAt && performance.now() < flashAt.until) {
    sctx.strokeStyle = '#ffd166'; sctx.lineWidth = 2;
    sctx.beginPath(); sctx.arc(flashAt.x, flashAt.y, 10, 0, Math.PI*2); sctx.stroke();
    requestAnimationFrame(drawSeedBoard);
  } else {
    flashAt = null;
  }

  if (points.length === 7) {
    sctx.strokeStyle = '#94a3b8';
    sctx.lineWidth = 2; sctx.lineCap='round'; sctx.lineJoin='round';
    sctx.beginPath();
    sctx.moveTo(points[0].x, points[0].y);
    for (let i=1;i<7;i++) sctx.lineTo(points[i].x, points[i].y);
    sctx.lineTo(points[0].x, points[0].y); // 닫기
    sctx.stroke();
    seedDbg.textContent = "시드 준비 완료. Start를 누르고 VR로 보세요.";
  } else {
    seedDbg.textContent = "7개의 점을 찍어 시드를 만드세요.";
  }
}

function withinRect(x, y, rect) {
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

function clientToCanvas(x, y, rect) {
  // sctx는 setTransform으로 CSS 좌표계==그리기 좌표계이므로 rect 기준 좌표만 넣으면 됨
  return { x: Math.max(0, Math.min(rect.width,  x - rect.left)),
           y: Math.max(0, Math.min(rect.height, y - rect.top )) };
}

function updateEventDbg(type, x, y, rect) {
  const rtxt = rect ? `${Math.round(rect.left)},${Math.round(rect.top)} ${Math.round(rect.width)}×${Math.round(rect.height)}` : '-';
  eventDbg.textContent = `event: ${type} / x:${x} y:${y} / rect: ${rtxt}`;
}

function tryAddPointFromClient(clientX, clientY, typeLabel='-') {
  const now = performance.now();
  if (now - lastAddTs < 50) return; // 중복 방지
  const rect = seedCanvas.getBoundingClientRect();
  if (!withinRect(clientX, clientY, rect)) return;

  const { x, y } = clientToCanvas(clientX, clientY, rect);
  points.push({ x: Math.round(x), y: Math.round(y) });
  TX_CNT.textContent = String(points.length);
  flashAt = { x, y, until: now + 200 };
  updateEventDbg(typeLabel, Math.round(x), Math.round(y), rect);

  if (points.length === 7) {
    seedReady = true; BTN_START.disabled = false;
  }
  lastAddTs = now;
  drawSeedBoard();
}

/* —— 이벤트 수집 (타겟 + 전역 백업) —— */
// 타겟: 씨드 캔버스 직접
seedCanvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'pointerdown'); }, {passive:false});
seedCanvas.addEventListener('mousedown',    (e)=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'mousedown'); }, {passive:false});
seedCanvas.addEventListener('click',        (e)=>{ e.preventDefault(); tryAddPointFromClient(e.clientX, e.clientY, 'click'); }, {passive:false});
seedCanvas.addEventListener('touchstart',   (e)=>{ if (e.changedTouches?.length){ const t=e.changedTouches[0]; tryAddPointFromClient(t.clientX, t.clientY, 'touchstart'); e.preventDefault(); }}, {passive:false});
seedCanvas.addEventListener('touchend',     (e)=>{ if (e.changedTouches?.length){ const t=e.changedTouches[0]; tryAddPointFromClient(t.clientX, t.clientY, 'touchend'); e.preventDefault(); }}, {passive:false});

// 전역 백업: 어떤 요소가 타겟을 가려도 rect 내부 클릭이면 수집
document.addEventListener('pointerdown', (e)=>{ tryAddPointFromClient(e.clientX, e.clientY, 'doc:pointerdown'); }, {passive:true});
document.addEventListener('mousedown',    (e)=>{ tryAddPointFromClient(e.clientX, e.clientY, 'doc:mousedown'); }, {passive:true});
document.addEventListener('click',        (e)=>{ tryAddPointFromClient(e.clientX, e.clientY, 'doc:click'); }, {passive:true});
document.addEventListener('touchstart',   (e)=>{ const t=e.changedTouches?.[0]; if(t) tryAddPointFromClient(t.clientX, t.clientY, 'doc:touchstart'); }, {passive:true});
document.addEventListener('touchend',     (e)=>{ const t=e.changedTouches?.[0]; if(t) tryAddPointFromClient(t.clientX, t.clientY, 'doc:touchend'); }, {passive:true});

BTN_CLR.addEventListener('click', ()=>{
  points = []; seedReady = false; TX_CNT.textContent = '0';
  BTN_START.disabled = true; drawSeedBoard();
});

/* ---------- RNG from 7 points ---------- */
function fnv1a32_fromPoints(pts) {
  let h = 0x811c9dc5 >>> 0;
  for (const p of pts) {
    const xi=p.x|0, yi=p.y|0;
    h ^= (xi & 0xff); h = Math.imul(h, 0x01000193);
    h ^= ((xi>>>8) & 0xff); h = Math.imul(h, 0x01000193);
    h ^= (yi & 0xff); h = Math.imul(h, 0x01000193);
    h ^= ((yi>>>8) & 0xff); h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}
function mulberry32(seed){ let a=seed>>>0; return function(){ a=(a+0x6D2B79F5)>>>0;
  let t=Math.imul(a^(a>>>15),(a|1)); t^=t+Math.imul(t^(t>>>7),(t|61)); return ((t^(t>>>14))>>>0)/4294967296; };}
function laneSeed(seed32, i){ let x=(seed32 ^ (i*0x9E3779B9))>>>0; x^=x<<13; x^=x>>>17; x^=x<<5; return x>>>0; }

/* ---------- Wave (부드럽고 우아한 형태) ---------- */
class Wave {
  constructor(idx, rng, inverted=false) {
    this.idx = idx;
    this.periodPx = 380 + rng()*280; // 380~660
    this.a1 = 0.50 + rng()*0.25;
    this.a2 = (0.08 + rng()*0.10) * (rng()<0.7?1:0.6);
    this.a3 = (rng()<0.35) ? (0.04 + rng()*0.06) : 0;
    this.p1 = rng()*Math.PI;
    this.p2 = this.p1*0.5 + rng()*0.6;
    this.p3 = this.p1*0.33 + rng()*0.6;
    this.bias = (rng()*0.06 - 0.03);
    this.troughBoost = 1.3 + rng()*0.9; // 1.3~2.2
    this.hue = Math.floor(rng()*360);
    this.inverted = inverted;
  }
  base(t){ return this.a1*Math.sin(t+this.p1)+this.a2*Math.sin(2*t+this.p2)+this.a3*Math.sin(3*t+this.p3)+this.bias; }
  asym(v){ const alpha=0.22; const wNeg=0.5*(1-Math.tanh(v/alpha)); let out=v*(1+(this.troughBoost-1)*wNeg); if(this.inverted) out=-out; return Math.tanh(out*0.9)*1.05; }
  sample(u){ const t=u*2*Math.PI; return this.asym(this.base(t)); }
}

/* ---------- THREE/WebXR ---------- */
let renderer, scene, camera, clock;
let world;
const LINES = [];
const NUM_SAMPLES = 1024;
const WIDTH = 4.2;
const HEIGHT = 1.6;
let materialResolution = new THREE.Vector2();

function setupThree() {
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.xr.enabled = true;
  renderer.domElement.classList.add('webgl'); // 뒤 레이어
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0d);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.set(0, 1.6, 0.5);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x202025, 0.7);
  scene.add(hemi);

  world = new THREE.Group();
  world.position.set(0, 1.6, -2.2);
  scene.add(world);

  // 은은한 중앙선
  const baseline = new THREE.Mesh(
    new THREE.PlaneGeometry(WIDTH, 0.004),
    new THREE.MeshBasicMaterial({ color:0x2b2b33 })
  );
  world.add(baseline);

  clock = new THREE.Clock();

  function onResize(){
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    materialResolution.set(window.innerWidth, window.innerHeight);
    for (const e of LINES) e.material.resolution.copy(materialResolution);
  }
  window.addEventListener('resize', onResize);
  onResize();
}

/* ---------- 굵은 라인(Line2) ---------- */
function makeLineMaterial(hue, alpha=1.0) {
  const mat = new LineMaterial({
    color: new THREE.Color(`hsl(${hue},100%,60%)`).getHex(),
    linewidth: 0.02,          // 두께 (0.02~0.03 권장)
    transparent: alpha < 1.0,
    opacity: alpha,
    depthTest: true,
    dashed: false
  });
  mat.resolution.copy(materialResolution); // 필수
  return mat;
}
function createWaveLine(wave, alpha=1.0){
  const geom = new LineGeometry();
  const arr = new Float32Array(NUM_SAMPLES * 3);
  geom.setPositions(arr);
  const mat = makeLineMaterial(wave.hue, alpha);
  const line = new Line2(geom, mat);
  line.computeLineDistances();
  world.add(line);
  return { mesh: line, geometry: geom, positions: arr, material: mat, wave };
}
function updateLinePositions(entry, timePhase){
  const { positions, geometry, wave } = entry;
  for (let i=0;i<NUM_SAMPLES;i++){
    const u = i/(NUM_SAMPLES-1);
    const x = -WIDTH/2 + u*WIDTH;
    const uPhase = (u + timePhase) % 1.0;
    const y = wave.sample(uPhase) * (HEIGHT*0.5);
    const j = i*3;
    positions[j  ] = x;
    positions[j+1] = y;
    positions[j+2] = 0;
  }
  geometry.setPositions(positions);
}

/* ---------- 라인 관리 ---------- */
function clearWorld() {
  for (const e of LINES) {
    world.remove(e.mesh);
    e.geometry.dispose();
    e.material.dispose();
  }
  LINES.length = 0;
}

/* ---------- 10 normal + 10 inverted → 각 5개 랜덤 ---------- */
class WaveFactory {
  constructor(seed32){
    this.seed32 = seed32;
    this.normals = []; this.inverteds = [];
    for (let i=0;i<10;i++){
      this.normals.push( new Wave(i, mulberry32(laneSeed(seed32, i)), false) );
      this.inverteds.push( new Wave(i, mulberry32(laneSeed(seed32, i+97)), true) );
    }
  }
  pick(arr, rnd, n=5){
    const idx = arr.map((_,i)=>i);
    for (let i=idx.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
    return idx.slice(0,n).map(i=>arr[i]);
  }
  buildMixedLines(){
    clearWorld();
    const r1 = mulberry32(this.seed32 ^ 0xabc12345);
    const r2 = mulberry32(this.seed32 ^ 0x13579bdf);
    const chosen = [...this.pick(this.normals,r1,5), ...this.pick(this.inverteds,r2,5)];
    for (let k=0;k<chosen.length;k++){
      const w = chosen[k];
      const alpha = 0.9 - (k*0.02);
      const entry = createWaveLine(w, Math.max(0.6, alpha));
      LINES.push(entry);
    }
  }
}

/* ---------- 애니메이션 ---------- */
let running = false, factory = null;
function startAnimation(){
  if (running) return;
  running = true;
  renderer.setAnimationLoop(()=>{
    const t = performance.now()*0.001;
    const speed = 0.075;              // 우아한 속도
    const phase = (t * speed) % 1.0;  // 0..1
    for (const e of LINES) updateLinePositions(e, phase);
    renderer.render(scene, camera);
  });
}
function stopAnimation(){ running=false; renderer.setAnimationLoop(null); }

/* ---------- UI ---------- */
document.getElementById('btnStart').addEventListener('click', ()=>{
  if (!seedReady || points.length!==7) { alert('먼저 Seed 캔버스에 정확히 7점을 찍어주세요.'); return; }
  const seed32 = fnv1a32_fromPoints(points);
  factory = new WaveFactory(seed32);
  factory.buildMixedLines();   // 정상 5 + 인버트 5
  startAnimation();
});
document.getElementById('btnReset').addEventListener('click', ()=>{
  stopAnimation();
  clearWorld();
  points=[]; seedReady=false; TX_CNT.textContent='0'; BTN_START.disabled=true; drawSeedBoard();
});

/* ---------- init ---------- */
function init(){
  // 첫 그리기
  drawSeedBoard();
  setupThree();
}
init();
</script>
</body>
</html>
