<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VR Wave Mixer — Smooth & Thick (Oculus/WebXR)</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#0b0b0d; color:#e5e7eb; font-family:system-ui, sans-serif; }
  .ui { position:fixed; inset:0 auto auto 0; padding:12px; display:flex; flex-direction:column; gap:10px; width:min(480px, 95vw); background:linear-gradient(180deg, #0b0b0df0, #0b0b0db0 40%, transparent); z-index:10; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  button { padding:8px 14px; border-radius:10px; border:1px solid #3a3a3a; background:#141416; color:#fff; cursor:pointer; }
  button[disabled] { opacity:.5; cursor:not-allowed; }
  button:hover:not([disabled]) { background:#1b1d20; }
  #seedWrap { position:relative; }
  #seedCanvas { display:block; width:420px; height:220px; background:#000; border:1px dashed #666; border-radius:10px; cursor: crosshair; touch-action:none; }
  #seedDbg { font:12px/1.2 monospace; color:#cbd5e1; white-space:pre; }
  .hint { color:#9ca3af; font-size:12px; }
</style>
</head>
<body>

<div class="ui">
  <div class="row">
    <button id="btnStart" disabled>Start → Build & Animate</button>
    <button id="btnReset">Reset</button>
    <div style="flex:1 1 auto;"></div>
    <div id="seedDbg">7개의 점을 찍어 시드를 만드세요.</div>
  </div>
  <div class="row">
    <div id="seedWrap">
      <canvas id="seedCanvas" title="여기에 7번 클릭하여 시드 생성"></canvas>
    </div>
    <div>Clicks: <b id="clickCount">0</b>/7</div>
    <button id="btnClearPts">Clear Points</button>
  </div>
  <div class="hint">Start를 누르면 같은 시드로 생성한 <b>정상 10 + 인버티드 10</b> 중 <b>각 5개씩</b>을 뽑아 <b>총 10개</b>를 한 화면에 겹쳐 보여줍니다. 상단의 “Enter VR” 버튼으로 Oculus에서 보세요.</div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";
import { VRButton } from "https://unpkg.com/three@0.160.1/examples/jsm/webxr/VRButton.js";
/* ✅ 굵은 라인(Line2) */
import { Line2 } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/Line2.js";
import { LineMaterial } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/LineMaterial.js";
import { LineGeometry } from "https://unpkg.com/three@0.160.1/examples/jsm/lines/LineGeometry.js";

/* ---------- Seed UI ---------- */
const seedCanvas = document.getElementById('seedCanvas');
const sctx = seedCanvas.getContext('2d');
const seedDbg = document.getElementById('seedDbg');
const TX_CNT = document.getElementById('clickCount');
const BTN_START = document.getElementById('btnStart');
const BTN_RST = document.getElementById('btnReset');
const BTN_CLR = document.getElementById('btnClearPts');

const seedCSS = { w:420, h:220 };
let points = [], seedReady = false;

function resizeSeedCanvasForDPR() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  seedCanvas.width = Math.round(seedCSS.w * dpr);
  seedCanvas.height= Math.round(seedCSS.h * dpr);
  sctx.setTransform(dpr,0,0,dpr,0,0);
  drawSeedBoard();
}
window.addEventListener('resize', resizeSeedCanvasForDPR);

function drawSeedBoard() {
  sctx.fillStyle = '#000'; sctx.fillRect(0,0,seedCSS.w,seedCSS.h);
  sctx.strokeStyle = '#666'; sctx.setLineDash([6,4]);
  sctx.strokeRect(1,1,seedCSS.w-2, seedCSS.h-2); sctx.setLineDash([]);

  for (const p of points) {
    sctx.fillStyle = '#ff4d6d';
    sctx.beginPath(); sctx.arc(p.x, p.y, 5, 0, Math.PI*2); sctx.fill();
  }
  if (points.length === 7) {
    sctx.strokeStyle = '#94a3b8';
    sctx.lineWidth = 2; sctx.lineCap='round'; sctx.lineJoin='round';
    sctx.beginPath();
    sctx.moveTo(points[0].x, points[0].y);
    for (let i=1;i<7;i++) sctx.lineTo(points[i].x, points[i].y);
    sctx.lineTo(points[0].x, points[0].y); // 폐곡선
    sctx.stroke();
  }
  seedDbg.textContent = points.length===7 ? "시드 준비 완료. Start를 누르고 VR로 보세요." : "7개의 점을 찍어 시드를 만드세요.";
}
function getSeedXY(evt) {
  const e = evt.touches?.[0] || evt;
  const rect = seedCanvas.getBoundingClientRect();
  const sx = seedCSS.w / rect.width, sy = seedCSS.h / rect.height;
  const x = (e.clientX - rect.left) * sx;
  const y = (e.clientY - rect.top) * sy;
  return { x: Math.max(0, Math.min(seedCSS.w, x)), y: Math.max(0, Math.min(seedCSS.h, y)) };
}
seedCanvas.addEventListener('pointerdown', e => seedCanvas.setPointerCapture?.(e.pointerId));
seedCanvas.addEventListener('pointerup', e => {
  try{ seedCanvas.releasePointerCapture?.(e.pointerId);}catch(_){}
  if (points.length >= 7) return;
  const {x,y} = getSeedXY(e);
  points.push({ x: Math.round(x), y: Math.round(y) });
  TX_CNT.textContent = String(points.length);
  if (points.length === 7) { seedReady = true; BTN_START.disabled = false; }
  drawSeedBoard();
}, {passive:false});
BTN_CLR.addEventListener('click', ()=>{
  points = []; seedReady = false; TX_CNT.textContent = '0';
  BTN_START.disabled = true; drawSeedBoard();
});

/* ---------- RNG from 7 points ---------- */
function fnv1a32_fromPoints(pts) {
  let h = 0x811c9dc5 >>> 0;
  for (const p of pts) {
    const xi=p.x|0, yi=p.y|0;
    h ^= (xi & 0xff); h = Math.imul(h, 0x01000193);
    h ^= ((xi>>>8) & 0xff); h = Math.imul(h, 0x01000193);
    h ^= (yi & 0xff); h = Math.imul(h, 0x01000193);
    h ^= ((yi>>>8) & 0xff); h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}
function mulberry32(seed){ let a=seed>>>0; return function(){ a=(a+0x6D2B79F5)>>>0;
  let t=Math.imul(a^(a>>>15),(a|1)); t^=t+Math.imul(t^(t>>>7),(t|61)); return ((t^(t>>>14))>>>0)/4294967296; };}
function laneSeed(seed32, i){ let x=(seed32 ^ (i*0x9E3779B9))>>>0; x^=x<<13; x^=x>>>17; x^=x<<5; return x>>>0; }

/* ---------- Wave (더 매끈 & 덜 요란) ---------- */
class Wave {
  constructor(idx, rng, inverted=false) {
    this.idx = idx;
    // 주기: 조금 더 길게 → 부드럽고 우아한 곡선
    this.periodPx = 380 + rng()*280; // 380~660
    // 진폭: 1×는 충분히, 2×는 약하게, 3×는 간혹 아주 약하게만
    this.a1 = 0.50 + rng()*0.25;                 // 0.50~0.75
    this.a2 = (0.08 + rng()*0.10) * (rng()<0.7?1:0.6); // 0.08~0.18
    this.a3 = (rng()<0.35) ? (0.04 + rng()*0.06) : 0;  // 0~0.10 (가끔만)
    // 위상: 2×,3×는 1×와 연관성 있게 살짝만 오프셋 → 결이 고와짐
    this.p1 = rng()*Math.PI;
    this.p2 = this.p1*0.5 + rng()*0.6;
    this.p3 = this.p1*0.33 + rng()*0.6;
    // 바이어스: 거의 0에 가깝게 (센터를 스치듯)
    this.bias = (rng()*0.06 - 0.03);
    // 음수 강화: 과도하지 않게(깊지만 우아하게)
    this.troughBoost = 1.3 + rng()*0.9; // 1.3~2.2
    this.hue = Math.floor(rng()*360);
    this.inverted = inverted;
  }
  base(t){
    return this.a1*Math.sin(t+this.p1)
         + this.a2*Math.sin(2*t+this.p2)
         + this.a3*Math.sin(3*t+this.p3)
         + this.bias;
  }
  asym(v){
    const alpha = 0.22; // 전이 폭을 넓혀 더 둥글게
    const wNeg = 0.5 * (1 - Math.tanh(v/alpha));
    let out = v * (1 + (this.troughBoost - 1) * wNeg);
    if (this.inverted) out = -out;
    // 살짝만 부드러운 S-커브를 추가(미세 곡률 통일)
    return Math.tanh(out * 0.9) * 1.05;
  }
  sample(u){ const t = u * 2*Math.PI; return this.asym(this.base(t)); }
}

/* ---------- THREE/WebXR setup ---------- */
let renderer, scene, camera, clock;
let world;
const LINES = [];
const NUM_SAMPLES = 1024;
const WIDTH = 4.0;
const HEIGHT = 1.6;   // 세로 범위를 약간 줄여 더 정갈하게
let materialResolution = new THREE.Vector2();

function setupThree() {
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0d);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.set(0, 1.6, 0.5);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x202025, 0.7);
  scene.add(hemi);

  world = new THREE.Group();
  world.position.set(0, 1.6, -2.2);
  scene.add(world);

  // 은은한 중앙선
  const baseline = new THREE.Mesh(
    new THREE.PlaneGeometry(WIDTH, 0.004),
    new THREE.MeshBasicMaterial({ color:0x2b2b33 })
  );
  world.add(baseline);

  clock = new THREE.Clock();

  function onResize(){
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    materialResolution.set(window.innerWidth, window.innerHeight);
    for (const e of LINES) {
      e.material.resolution.copy(materialResolution);
    }
  }
  window.addEventListener('resize', onResize);
  onResize();
}

/* ---------- 굵은 라인(Line2) 생성/업데이트 ---------- */
function makeLineMaterial(hue, alpha=1.0) {
  const mat = new LineMaterial({
    color: new THREE.Color(`hsl(${hue},100%,60%)`).getHex(),
    linewidth: 0.015,       // ✅ 굵기(월드 유닛). 0.015~0.025 사이 추천
    transparent: alpha < 1.0,
    opacity: alpha,
    dashed: false,
    depthTest: true
  });
  mat.resolution.copy(materialResolution); // 필수
  return mat;
}

function createWaveLine(wave, alpha=1.0){
  const geom = new LineGeometry();
  // 초기 포지션(빈 값), 프레임마다 setPositions로 교체
  const arr = new Float32Array(NUM_SAMPLES * 3);
  geom.setPositions(arr);
  const mat = makeLineMaterial(wave.hue, alpha);
  const line = new Line2(geom, mat);
  line.computeLineDistances();
  world.add(line);
  return { mesh: line, geometry: geom, positions: arr, material: mat, wave };
}

function updateLinePositions(entry, timePhase){
  const { positions, geometry, wave } = entry;
  for (let i=0;i<NUM_SAMPLES;i++){
    const u = i/(NUM_SAMPLES-1);
    const x = -WIDTH/2 + u*WIDTH;
    const uPhase = (u + timePhase) % 1.0;
    // 부드럽게: 아주 미세한 곡률 통일을 위해 저역 위주 스케일
    const y = wave.sample(uPhase) * (HEIGHT*0.5);
    const j = i*3;
    positions[j  ] = x;
    positions[j+1] = y;
    positions[j+2] = 0;
  }
  geometry.setPositions(positions);
}

/* ---------- 라인 관리 ---------- */
function clearWorld() {
  for (const e of LINES) {
    world.remove(e.mesh);
    e.geometry.dispose();
    e.material.dispose();
  }
  LINES.length = 0;
}

/* ---------- 10 normal + 10 inverted → 각 5개 랜덤 pick ---------- */
class WaveFactory {
  constructor(seed32){
    this.seed32 = seed32;
    this.normals = []; this.inverteds = [];
    for (let i=0;i<10;i++){
      this.normals.push( new Wave(i, mulberry32(laneSeed(seed32, i)), false) );
      this.inverteds.push( new Wave(i, mulberry32(laneSeed(seed32, i+97)), true) );
    }
  }
  pick(arr, rnd, n=5){
    const idx = arr.map((_,i)=>i);
    for (let i=idx.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
    return idx.slice(0,n).map(i=>arr[i]);
  }
  buildMixedLines(){
    clearWorld();
    const r1 = mulberry32(this.seed32 ^ 0xabc12345);
    const r2 = mulberry32(this.seed32 ^ 0x13579bdf);
    const chosen = [...this.pick(this.normals,r1,5), ...this.pick(this.inverteds,r2,5)];
    // 약간의 투명도 차로 겹침 미(美) 강화
    for (let k=0;k<chosen.length;k++){
      const w = chosen[k];
      const alpha = 0.9 - (k*0.02);
      const entry = createWaveLine(w, Math.max(0.6, alpha));
      LINES.push(entry);
    }
  }
}

/* ---------- 애니메이션 ---------- */
let running = false, factory = null;
function startAnimation(){
  if (running) return;
  running = true;
  renderer.setAnimationLoop(()=>{
    const t = performance.now()*0.001;
    const speed = 0.075; // 살짝 느리게 → 우아한 흐름
    const phase = (t * speed) % 1.0;
    for (const e of LINES) {
      updateLinePositions(e, phase);
    }
    renderer.render(scene, camera);
  });
}
function stopAnimation(){ running=false; renderer.setAnimationLoop(null); }

/* ---------- UI ---------- */
document.getElementById('btnStart').addEventListener('click', ()=>{
  if (!seedReady || points.length!==7) { alert('먼저 Seed 캔버스에 정확히 7점을 찍어주세요.'); return; }
  const seed32 = fnv1a32_fromPoints(points);
  factory = new WaveFactory(seed32);
  factory.buildMixedLines();   // 정상 5 + 인버트 5
  startAnimation();
});
document.getElementById('btnReset').addEventListener('click', ()=>{
  stopAnimation();
  clearWorld();
  points=[]; seedReady=false; TX_CNT.textContent='0'; BTN_START.disabled=true; drawSeedBoard();
});

/* ---------- init ---------- */
function init(){
  const dpr = Math.max(1, window.devicePixelRatio||1);
  seedCanvas.width = Math.round(seedCSS.w*dpr); seedCanvas.height = Math.round(seedCSS.h*dpr);
  sctx.setTransform(dpr,0,0,dpr,0,0);
  drawSeedBoard();
  setupThree();
}
init();
</script>
</body>
</html>
